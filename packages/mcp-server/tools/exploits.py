"""
MCP Tool: search_exploits

Searches the KAMIYO exploit database with subscription-tier-based feature gating.
This tool allows AI agents (like Claude) to search crypto exploit intelligence data
with access levels determined by the user's subscription tier.
"""

import sys
import os
from datetime import datetime, timedelta, timezone
from typing import Optional, List, Dict, Any

# Add parent directory to path for imports
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))

from database import get_db
import logging

logger = logging.getLogger(__name__)


# Subscription tier limits based on requirements
TIER_LIMITS = {
    "free": {
        "max_results": 10,
        "data_delay_hours": 24,
        "name": "Free"
    },
    "pro": {
        "max_results": 50,
        "data_delay_hours": 0,
        "name": "Pro"
    },
    "personal": {
        "max_results": 50,
        "data_delay_hours": 0,
        "name": "Personal"
    },
    "team": {
        "max_results": 200,
        "data_delay_hours": 0,
        "name": "Team"
    },
    "enterprise": {
        "max_results": 1000,
        "data_delay_hours": 0,
        "name": "Enterprise"
    }
}


def search_exploits(
    query: str,
    limit: int = 10,
    since: Optional[str] = None,
    chain: Optional[str] = None,
    user_tier: str = "free"
) -> Dict[str, Any]:
    """
    Search cryptocurrency exploits from KAMIYO database.

    This tool provides access to crypto exploit intelligence with subscription-based
    feature gating. Search by protocol name, token, vulnerability type, or chain.

    Args:
        query: Search term (protocol name, token, vulnerability type)
               Examples: "Ethereum", "flash loan", "Uniswap", "reentrancy"
        limit: Maximum number of results to return (default: 10)
               Note: Actual limit will be capped by subscription tier
        since: ISO 8601 date to search from (optional)
               Example: "2024-01-01T00:00:00Z"
               If not provided, searches all available data
        chain: Filter by blockchain (optional)
               Examples: "Ethereum", "BSC", "Polygon", "Solana"
        user_tier: Subscription tier (internal parameter, set by MCP server)
               Options: "free", "personal", "team", "enterprise"

    Returns:
        Dictionary containing:
        - exploits: List of matching exploits with full details
        - metadata: Search metadata including counts, tier info, sources
        - tier_info: Information about subscription tier limits
        - sources: List of data sources used

    Subscription Tier Limits:
        - Free: Max 10 results, 24h delayed data
        - Personal/Pro: Max 50 results, real-time data
        - Team: Max 200 results, real-time data
        - Enterprise: Max 1000 results, real-time data

    Example Response:
        {
            "exploits": [
                {
                    "id": 123,
                    "tx_hash": "0x...",
                    "chain": "Ethereum",
                    "protocol": "Uniswap V2",
                    "amount_usd": 1500000.0,
                    "timestamp": "2024-01-15T10:30:00Z",
                    "source": "BlockSec",
                    "category": "Flash Loan Attack",
                    "description": "...",
                    ...
                }
            ],
            "metadata": {
                "total_returned": 10,
                "total_matching": 45,
                "query": "Uniswap",
                "filters": {...},
                "search_time_ms": 42
            },
            "tier_info": {
                "tier": "free",
                "max_results": 10,
                "data_delay_hours": 24
            },
            "sources": ["BlockSec", "Rekt", "DeFiLlama"]
        }

    Error Handling:
        Returns error information in the response if search fails:
        {
            "error": "Error message",
            "exploits": [],
            "metadata": {...}
        }
    """
    start_time = datetime.now()

    try:
        # Normalize tier name (handle aliases)
        user_tier = user_tier.lower()
        if user_tier not in TIER_LIMITS:
            logger.warning(f"Unknown tier '{user_tier}', defaulting to 'free'")
            user_tier = "free"

        tier_config = TIER_LIMITS[user_tier]

        # Apply tier-based limit cap
        effective_limit = min(limit, tier_config["max_results"])

        # Parse 'since' date if provided
        since_datetime = None
        if since:
            try:
                # Handle ISO 8601 format
                since_datetime = datetime.fromisoformat(since.replace('Z', '+00:00'))
            except (ValueError, AttributeError) as e:
                logger.warning(f"Invalid 'since' date format: {since}, error: {e}")
                # Continue without date filter

        # Get database connection
        db = get_db()

        # Build query parameters
        query_lower = query.lower().strip()

        # Fetch exploits from database with filters
        # Note: Using get_recent_exploits as base, then filter by query
        all_exploits = db.get_recent_exploits(
            limit=1000,  # Fetch more to enable filtering
            offset=0,
            chain=chain,
            min_amount=None
        )

        # Filter exploits by search query
        # Search in: protocol name, description, category, chain
        matching_exploits = []
        for exploit in all_exploits:
            protocol = (exploit.get('protocol') or '').lower()
            description = (exploit.get('description') or '').lower()
            category = (exploit.get('category') or '').lower()
            exploit_chain = (exploit.get('chain') or '').lower()

            # Check if query matches any field
            if (query_lower in protocol or
                query_lower in description or
                query_lower in category or
                query_lower in exploit_chain):
                matching_exploits.append(exploit)

        # Apply date filter if provided
        if since_datetime:
            filtered = []
            for exploit in matching_exploits:
                exploit_timestamp = exploit.get('timestamp')
                if exploit_timestamp:
                    # Handle both datetime objects and strings
                    if isinstance(exploit_timestamp, str):
                        ts = datetime.fromisoformat(exploit_timestamp.replace('Z', '+00:00'))
                    else:
                        ts = exploit_timestamp

                    # Make timezone-aware if needed
                    if ts.tzinfo is None:
                        ts = ts.replace(tzinfo=timezone.utc)

                    # Make since_datetime timezone-aware if needed
                    if since_datetime.tzinfo is None:
                        since_datetime = since_datetime.replace(tzinfo=timezone.utc)

                    if ts >= since_datetime:
                        filtered.append(exploit)
            matching_exploits = filtered

        # Apply tier-based data delay for free tier
        if tier_config["data_delay_hours"] > 0:
            cutoff_time = datetime.now(timezone.utc) - timedelta(hours=tier_config["data_delay_hours"])
            delayed_exploits = []

            for exploit in matching_exploits:
                exploit_timestamp = exploit.get('timestamp')
                if exploit_timestamp:
                    # Handle both datetime objects and strings
                    if isinstance(exploit_timestamp, str):
                        ts = datetime.fromisoformat(exploit_timestamp.replace('Z', '+00:00'))
                    else:
                        ts = exploit_timestamp

                    # Make timezone-aware if needed
                    if ts.tzinfo is None:
                        ts = ts.replace(tzinfo=timezone.utc)

                    # Only include exploits older than cutoff
                    if ts < cutoff_time:
                        delayed_exploits.append(exploit)
                else:
                    # Keep exploits without timestamp
                    delayed_exploits.append(exploit)

            matching_exploits = delayed_exploits
            logger.info(f"Applied {tier_config['data_delay_hours']}h delay filter for {user_tier} tier")

        # Store total matching count before limiting
        total_matching = len(matching_exploits)

        # Apply result limit
        limited_exploits = matching_exploits[:effective_limit]

        # Format exploits for response
        formatted_exploits = []
        for exploit in limited_exploits:
            # Convert datetime objects to ISO strings
            timestamp = exploit.get('timestamp')
            if isinstance(timestamp, datetime):
                timestamp = timestamp.isoformat()

            formatted_exploits.append({
                "id": exploit.get('id'),
                "tx_hash": exploit.get('tx_hash'),
                "chain": exploit.get('chain'),
                "protocol": exploit.get('protocol'),
                "amount_usd": exploit.get('amount_usd', 0),
                "timestamp": timestamp,
                "source": exploit.get('source'),
                "source_url": exploit.get('source_url'),
                "category": exploit.get('category'),
                "description": exploit.get('description'),
                "recovery_status": exploit.get('recovery_status')
            })

        # Extract unique sources
        sources = list(set([e.get('source') for e in limited_exploits if e.get('source')]))

        # Calculate search time
        search_time_ms = int((datetime.now() - start_time).total_seconds() * 1000)

        # Build response
        response = {
            "exploits": formatted_exploits,
            "metadata": {
                "total_returned": len(formatted_exploits),
                "total_matching": total_matching,
                "query": query,
                "filters": {
                    "chain": chain,
                    "since": since
                },
                "search_time_ms": search_time_ms
            },
            "tier_info": {
                "tier": user_tier,
                "tier_name": tier_config["name"],
                "max_results": tier_config["max_results"],
                "data_delay_hours": tier_config["data_delay_hours"],
                "requested_limit": limit,
                "effective_limit": effective_limit
            },
            "sources": sorted(sources)
        }

        logger.info(
            f"Search completed: query='{query}', tier={user_tier}, "
            f"returned={len(formatted_exploits)}/{total_matching}, time={search_time_ms}ms"
        )

        return response

    except Exception as e:
        logger.error(f"Error searching exploits: {e}")
        import traceback
        logger.error(traceback.format_exc())

        # Return error response
        search_time_ms = int((datetime.now() - start_time).total_seconds() * 1000)

        return {
            "error": str(e),
            "error_type": type(e).__name__,
            "exploits": [],
            "metadata": {
                "total_returned": 0,
                "total_matching": 0,
                "query": query,
                "filters": {
                    "chain": chain,
                    "since": since
                },
                "search_time_ms": search_time_ms
            },
            "tier_info": {
                "tier": user_tier,
                "max_results": TIER_LIMITS.get(user_tier, TIER_LIMITS["free"])["max_results"],
                "data_delay_hours": TIER_LIMITS.get(user_tier, TIER_LIMITS["free"])["data_delay_hours"]
            },
            "sources": []
        }


# Test function for manual testing
if __name__ == "__main__":
    import json

    print("\n=== Testing search_exploits Tool ===\n")

    # Test 1: Basic search
    print("Test 1: Basic search for 'Ethereum'")
    result = search_exploits(query="Ethereum", limit=5)
    print(f"Results: {result['metadata']['total_returned']} of {result['metadata']['total_matching']}")
    print(f"Tier: {result['tier_info']['tier']} (max {result['tier_info']['max_results']})")

    # Test 2: Search with chain filter
    print("\nTest 2: Search for 'flash loan' on Ethereum")
    result = search_exploits(query="flash loan", chain="Ethereum", limit=3)
    print(f"Results: {result['metadata']['total_returned']}")

    # Test 3: Different tiers
    print("\nTest 3: Search with different tiers")
    for tier in ["free", "personal", "team", "enterprise"]:
        result = search_exploits(query="Uniswap", limit=100, user_tier=tier)
        print(f"  {tier}: max={result['tier_info']['max_results']}, delay={result['tier_info']['data_delay_hours']}h")

    print("\nâœ… Tests completed")
